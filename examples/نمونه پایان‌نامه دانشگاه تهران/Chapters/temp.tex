
 در یک تعریف کلی 
\gls{Privacy}
اطلاعات را می‌توان به صورت زیر تعریف نمود. 
\begin{ntdefinition}[\glsentrytext{Privacy} اطلاعات]
عبارت است از هر گونه اطلاعاتی که به نوعی مربوط به
 \glsentrytext{User} 
  یا
  \glsentrytext{Entity}\footnotemark
  ی درون
   \glsentrytext{System}
    است و  می‌تواند بالقوه مورد استفاده سوء توسط
     \glsentrytext{Adversary}
      قرار گیرد.
\end{ntdefinition}
ذکر این نکته خالی از لطف نیست که 
‎\gls{Anonymity}‎   و ‎ \gls{Privacy}‎
در عین تشابه، تفاوت ظریفی بایکدیگر دارند. در ‎\gls{Anonymity}‎ قصد داریم تا  کسی نداند که شما کیستید، گرچه ممکن است او بداند که شما چه می‌کنید! اما در ‎\gls{Privacy}‎ به دنبال این هستیم که کسی نداند که شما چه می‌کنید، گرچه ممکن است بداند که شما که هستید
\cite[صفحه ۳۴۱]{Stewart2013Network}.


\subsection{}
برای درک هرچه بهتر مفهوم
\gls{TemporalAndStatisticalPrivacy}،
سه فرد مشهور در دنیای
\gls{Security} یعنی \lr{Alice}, \lr{Bob} و \lr{Eve}
را بار دیگر بکار می‌گیریم. فرض کنید که
\lr{Alice}
بر روی رایانه خود تعداد 
$N$ \gls{Application}
را اجرا می‌کند. پیام‌های تولیدی توسط این
\glspl{Application}
به سوی
\lr{Bob}
ارسال می‌گردد. یک
\gls{Adversary} به نام \lr{Eve}،
بر سر راه ارتباطی بین 
\lr{Alice}‌و \lr{Bob}
نشسته و پیام‌های ارسالی آن‌ها را  مشاهده می‌کنید. هدف \lr{Eve} یافتن هرگونه اطلاعاتی در مورد این پیام‌ها است. همان‌طور که می‌دانید بسته‌های تولیدی توسط اکثر 
\glspl{Application}ی
اجرا شده، رمز شده‌اند. بدین‌سان به نظر می‌رسد او نتواند به محتوای 
\glspl{Packet}ی
ارسالی پی ببرد. 
اولین پرسشی که مطرح می‌گردد، این است که بحث ‎\gls{TemporalPrivacy}‎، از دیدگاه ذکر شده، چه کاربردی  دارد. در ادامه به برخی از کاربردهای این مساله خواهیم پرداخت. لازم به ذکر است که، مساله  ‎\gls{TemporalPrivacy}‎ از سوی دو گروه حائز اهمیت است؛ ‎\gls{Attacker}‎ که در خروجی سامانه به شنود اطلاعات می‌پردازد، و از سوی دیگر، کاربر که قصد ‎\gls{TemporalPrivacy} خود را دارد.

نشان داده شده است که 
\gls*{Adversary}
می‌تواند با تحلیل الگوی ترافیک کاربردهای اجرا شده در سمت کاربر در یک شبکه،
\gls*{Privacy}
او را نقض نماید. تحلیل آماری که توسط
\gls*{Adversary}
صورت می‌پذیرد، این امر را آشکار نموده است که حتی در صورت استفاده از سازوکارهای تامین امنیت اطلاعات به مانند رمزنگاری، باز مهاجم می‌تواند اطلاعاتی را در مورد کاربرد اجرا شده در سمت کاربر بدست آورد. اگر گره مبدا به منظور حفظ 
\gls*{Privacy}
خود کنش مناسبی را انجام ندهد، 
\gls*{Adversary}
می‌تواند با دست یافتن به اطلاعاتی نظیر میانگین، پراش و یا توزیع زمان خروج بسته‌ها، پی به نحوه رفتار گره مبدا ببرد. در این رساله ما به دنبال آن هستیم که 



تاکنون \gls*{Security} داده از جنبه‌های مختلفی به مانند
\gls*{Encryption}, \gls*{Authentication}, \gls*{Integrity}‌, \gls*{Freshness}
و‌غیره، مورد بحث و بررسی قرار گرفته است.  اما  حوزه امنیت به مواردی که اشاره شد، محدود نمی‌گردد. امروزه باتوجه به وجود شبکه‌هایی با پروتکل‌های اختصاصی نظیر ‎\lr{Skype}‎ و عدم دسترسی به محتوای برخی از لایه‌های شبکه به دلیل رمزشدن آن‌ها، جنبه‌ای دیگر از امنیت که ما از آن با عنوان
\gls*{TemporalAndStatisticalPrivacy}
یاد می‌کنیم، نیز مطرح گشته است. در این دیدگاه،
\gls*{Adversary}
می‌تواند با بررسی ساختار زمانی ارسال \glspl*{Packet} (اعم از  تحلیل زمان‌های ‌قطعی  ارسال و یا ویژگی‌های آماری آن‌ها)، به اطلاعاتی در مورد ‎\gls*{Application}‎ مورد استفاده در سمت \gls*{SourceNode} پی ببرد، بدون آن‌که نیاز به دسترسی به محتوای \glspl*{Application} داشته باشد. به عبارت‌بهتر و از دیدگاه علم
\glspl*{ComputerNetwork}، \gls*{Adversary}
بدون داشتن اطلاعاتی در مورد 
\gls*{ApplicationLayer} و \gls*{TransportLayer}،
و فقط با داشتن اطلاعات زمانی ارسال 
\glspl*{Packet} در \gls*{NetworkLayer}، \gls*{Privacy} \gls*{User}
را به خطر بیاندازد. 

در این رساله، با استفاده از 
‎\gls*{QueuingTheory}‎ و \gls*{InformationTheory}
این جنبه از
\gls*{Privacy}
را مورد بررسی قرار خواهیم داد. ما در ابتدا به سراغ
\gls*{Rate}
تولید داده در \gls*{SourceNode} می‌رویم. خواهیم گفت که یک
\gls*{Adversary}
باهوش می‌تواند با بهره‌گرفتن از
\gls*{FlowConservationLaw} و با استفاده از \gls*{Rate}، \gls*{TemporalAndStatisticalPrivacy} \gls*{User}
را به خطر بیاندازد. البته در ادامه خود را محدود به 
\gls*{Rate}
نخواهیم کرد و از یک
\gls*{Feature}
به صورت کلی سخن به میان خواهد آمد. برای
\gls*{Feature} \gls*{Rate}
راه‌کاری نیز مبتنی بر اضافه نمودن
\glspl*{DummyPacket}
ارایه می‌گردد. در ضمن گذری نیز بر 
\gls*{TemporalAndStatisticalPrivacy} در \glspl*{CachingSystem}
خواهیم داشت.
\gls*{Adversary} 
باشنود کانال در مرحله
\gls*{Delivery} در \glspl*{CachingSystem}،
می‌تواند 
\gls*{Privacy} \glspl*{User}
را به خطر بیاندازد، بدین‌سان که می‌تواند دریابد که با احتمال زیادی یک
\gls*{User}،
چه فایلی را درخواست کرده‌است. 

روش‌های پیشنهادی در کل این رساله، می‌بایست به نحوی باشد که  ضمن حفظ
\gls*{TemporalAndStatisticalPrivacy}، ‎\gls*{QoS}‎ \gls*{User}
را نیز حفظ نماید. تمامی روش‌های پیشنهادی ارایه شده در این رساله، بر پایه تعدادی
\gls*{OptimizationProblem}،
استوار است که 
\gls*{TradeOff} بین \gls*{Privacy} و \gls*{Cost}
را مدیریت می‌نماید. از سوی دیگر به منظور مدل‌سازی هرچه بهتر مفهوم
\gls*{Privacy}، 
به سراغ یافتن یک‌سری
\gls*{LowerBound} برای \gls*{AdversarysBestEstimationErrorProbability}
خواهیم رفت. در این راه از باندهای پیشنهاد شده در مبحث 
\glspl*{CommunicationChannel} که در علم \gls*{InformationTheory}
مورد بحث قرار می‌گیرد، استفاده کرده‌ایم.
